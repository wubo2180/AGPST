# 📊 异常值分析详解

## 1️⃣ 什么是异常值？

**异常值（Outliers）** 是指在数据集中明显偏离大多数数据点的观测值。在交通流量数据中，异常值可能由以下原因产生：

### 常见原因

| 原因类型 | 示例 | 影响 |
|---------|------|------|
| 🚧 **特殊事件** | 交通事故、道路施工 | 流量突然大幅下降 |
| 🎉 **节假日** | 春节、国庆 | 流量异常增加/减少 |
| 🔧 **传感器故障** | 设备损坏、通信中断 | 数据缺失或错误读数 |
| ⚡ **极端天气** | 暴雨、大雪 | 流量异常波动 |
| 📊 **数据采集错误** | 传输错误、记录错误 | 不合理的数值 |

---

## 2️⃣ 异常值检测方法

### 方法1: IQR（四分位距）方法 ⭐ **当前使用**

**原理**：基于数据的分位数来识别异常值

```python
# 计算四分位数
Q1 = 第25百分位数（下四分位数）
Q3 = 第75百分位数（上四分位数）
IQR = Q3 - Q1  # 四分位距

# 定义异常值边界
下界 = Q1 - 1.5 × IQR
上界 = Q3 + 1.5 × IQR

# 判断异常值
异常值 = (数据 < 下界) 或 (数据 > 上界)
```

**可视化示例**：
```
        异常值 ←|
                |
    上界 -------|-------  Q3 + 1.5×IQR
                |
                ├─────── Q3 (75%)
                │
                │  正常数据区域
                │
                ├─────── Q2 (中位数, 50%)
                │
                │  正常数据区域
                │
                ├─────── Q1 (25%)
                |
    下界 -------|-------  Q1 - 1.5×IQR
                |
        异常值 ←|
```

**优点**：
- ✅ 不受极端值影响（鲁棒性强）
- ✅ 适合偏态分布
- ✅ 计算简单高效
- ✅ 统计学上有明确意义

**缺点**：
- ⚠️ 对于多峰分布可能不准确
- ⚠️ 1.5倍系数是经验值，可能需要调整

---

### 方法2: Z-Score（标准分数）方法

**原理**：基于均值和标准差来识别异常值

```python
# 计算Z分数
mean = 数据均值
std = 数据标准差
z_score = |数据 - mean| / std

# 判断异常值（通常使用3倍标准差）
异常值 = z_score > 3
```

**可视化示例**（假设正态分布）：
```
                    3σ区间
    ←───────────────────────────────────→
    
    μ-3σ    μ-2σ    μ-1σ    μ    μ+1σ    μ+2σ    μ+3σ
     ↓       ↓       ↓      ↓      ↓       ↓       ↓
     |       |       |      |      |       |       |
   异常   ├───────正常数据区域(99.7%)───────┤   异常
```

**优点**：
- ✅ 概率意义明确（正态分布下）
- ✅ 适合对称分布

**缺点**：
- ❌ 受极端值影响大
- ❌ 假设数据服从正态分布
- ❌ 对偏态分布效果差

---

## 3️⃣ 异常值分析代码详解

### 完整代码

```python
def detect_outliers(data, method='iqr'):
    """
    检测异常值
    
    Args:
        data: 形状为 (T, N) 的数据
              T = 时间步数
              N = 节点数
        method: 'iqr' 或 'zscore'
    
    Returns:
        outliers: 布尔数组，True表示异常值
        outlier_ratio: 异常值占比（百分比）
    """
    T, N = data.shape
    
    if method == 'iqr':
        # IQR方法 - 对每个节点单独计算
        q1 = np.percentile(data, 25, axis=0)  # (N,) 每个节点的Q1
        q3 = np.percentile(data, 75, axis=0)  # (N,) 每个节点的Q3
        iqr = q3 - q1  # (N,) 每个节点的IQR
        
        # 计算边界
        lower_bound = q1 - 1.5 * iqr  # (N,)
        upper_bound = q3 + 1.5 * iqr  # (N,)
        
        # 广播比较: (T, N) vs (N,) -> (T, N)
        outliers = (data < lower_bound) | (data > upper_bound)
        
    elif method == 'zscore':
        # Z-score方法
        mean = np.mean(data, axis=0)  # (N,)
        std = np.std(data, axis=0)    # (N,)
        z_scores = np.abs((data - mean) / (std + 1e-8))
        
        outliers = z_scores > 3  # (T, N)
    
    # 计算总体异常值比例
    outlier_ratio = (outliers.sum() / outliers.size) * 100
    
    return outliers, outlier_ratio
```

### 逐步解析

#### 步骤1: 计算四分位数
```python
q1 = np.percentile(data, 25, axis=0)
# 沿时间轴(axis=0)计算，得到每个节点的Q1
# 输入: (T, N)  →  输出: (N,)
```

#### 步骤2: 计算IQR和边界
```python
iqr = q3 - q1
lower_bound = q1 - 1.5 * iqr
upper_bound = q3 + 1.5 * iqr
# 所有操作在 (N,) 维度上进行
```

#### 步骤3: 判断异常值
```python
outliers = (data < lower_bound) | (data > upper_bound)
# NumPy广播: (T,N) vs (N,) → (T,N)
# 结果: True/False 布尔数组
```

#### 步骤4: 计算比例
```python
outlier_ratio = (outliers.sum() / outliers.size) * 100
# outliers.sum() = 所有True的个数
# outliers.size = T × N (总数据点数)
```

---

## 4️⃣ 可视化图表详解

### 📊 异常值分布柱状图

```
各节点异常值数量
     ↑
200  |     █
     |     █
150  |     █  █
     | █   █  █     █
100  | █   █  █  █  █
     | █ █ █  █  █  █
 50  | █ █ █  █  █  █  █
     | █ █ █  █  █  █  █
  0  |─────────────────────→
       0   1   2   3   4 ... N
           节点索引
```

### 图表元素说明

| 元素 | 含义 | 解读 |
|------|------|------|
| **X轴** | 节点索引 (0 到 N-1) | 每个传感器/路段的编号 |
| **Y轴** | 异常值数量 | 该节点在所有时间步中的异常值个数 |
| **柱子高度** | 异常值频率 | 越高说明该节点越不稳定 |
| **文本框** | 总异常值比例 | 整个数据集的异常值占比 |

### 如何解读

#### 🟢 **健康情况**（柱子低且均匀）
```
 50 |
    | █ █ █ █ █ █ █
  0 |─────────────────
      均匀分布，数值低
```
- ✅ 数据质量好
- ✅ 传感器工作正常
- ✅ 流量变化规律

#### 🟡 **中等情况**（部分节点较高）
```
150 |     █
100 |     █   █
 50 | █ █ █ █ █ █ █
  0 |─────────────────
      个别节点突出
```
- ⚠️ 某些节点不稳定
- ⚠️ 可能是特殊位置（如高速公路出入口）
- 💡 需要重点关注这些节点

#### 🔴 **问题情况**（多个节点很高）
```
300 | █   █     █
200 | █   █   █ █
100 | █ █ █ █ █ █ █
  0 |─────────────────
      多个高峰
```
- ❌ 数据质量差
- ❌ 传感器故障频繁
- ❌ 极端事件多
- 🚨 强烈需要去噪处理

---

## 5️⃣ 实际案例分析

### 案例1: PEMS03数据集

假设分析结果如下：
```
总异常值比例: 2.34%
```

**解读**：
- 📊 **总体情况**：2.34%的异常值比例属于 **正常范围**（一般<5%）
- ✅ **数据质量**：较好，大部分数据可信
- 💡 **建议**：可以使用轻量级去噪（conv）或不去噪

### 案例2: 高异常值数据集

假设分析结果如下：
```
总异常值比例: 8.76%
```

**解读**：
- ⚠️ **总体情况**：8.76%偏高（>5%）
- 🔴 **问题**：
  - 传感器可能不稳定
  - 包含较多特殊事件
  - 数据采集质量有问题
- 💡 **建议**：
  - 使用强力去噪（attention）
  - 考虑数据清洗
  - 检查原始数据源

### 柱状图模式识别

#### 模式1: 均匀分布（理想）
```python
# 所有节点异常值数量相近
outlier_counts = [45, 52, 48, 51, 47, 49, 50, 46]
# 标准差小，说明各节点质量一致
```

#### 模式2: 个别突出（部分问题）
```python
# 大部分节点正常，个别节点异常值多
outlier_counts = [48, 50, 45, 247, 52, 49, 51, 46]
#                              ↑ 问题节点
# 需要单独分析这些节点
```

#### 模式3: 多峰分布（系统性问题）
```python
# 明显的分组模式
outlier_counts = [150, 148, 152, 45, 48, 50, 155, 147]
#                  高值组            低值组    高值组
# 可能是不同类型的传感器或位置
```

---

## 6️⃣ 异常值对模型的影响

### 不处理异常值的后果

```python
# 训练时
异常值 → 极端梯度 → 参数更新不稳定 → 训练困难

# 预测时
模型过拟合异常值 → 泛化能力差 → 预测不准确
```

### 处理方法对比

| 方法 | 适用场景 | 效果 |
|------|----------|------|
| **忽略** | 异常值<2% | ⚠️ 可能影响性能 |
| **删除/填充** | 异常值集中在少数节点 | ✅ 提升数据质量 |
| **卷积去噪** | 异常值2-5% | ✅ 平滑处理 |
| **注意力去噪** | 异常值>5% | ✅ 自适应处理 |
| **鲁棒损失** | 无法预处理 | ✅ 训练时抑制影响 |

---

## 7️⃣ 与其他指标的联系

### 异常值 vs SNR（信噪比）

| 异常值比例 | SNR | 关系 |
|-----------|-----|------|
| 高 (>5%) | 低 (<15 dB) | 强负相关：异常值多→噪声大 |
| 低 (<2%) | 高 (>25 dB) | 数据质量好 |
| 高但SNR中等 | | 可能是系统性偏差而非随机噪声 |

### 异常值 vs 高频能量

| 异常值 | 高频能量 | 解释 |
|-------|---------|------|
| 多 | 高 | 异常值产生高频突变 |
| 多 | 低 | 低频漂移或系统性偏差 |
| 少 | 高 | 快速但规律的变化（正常） |

---

## 8️⃣ 代码使用示例

### 基本使用

```python
# 加载数据
data = np.load('datasets/PEMS03/train_data.npy')  # (T, N)

# 检测异常值
outliers, ratio = detect_outliers(data, method='iqr')

print(f"异常值比例: {ratio:.2f}%")
print(f"异常值总数: {outliers.sum()}")

# 查看每个节点的异常值数量
outlier_counts = outliers.sum(axis=0)  # (N,)
print(f"节点0的异常值: {outlier_counts[0]}")
```

### 找出问题节点

```python
# 找出异常值最多的节点
top_k = 5
top_nodes = np.argsort(outlier_counts)[-top_k:][::-1]

print(f"异常值最多的{top_k}个节点:")
for i, node_id in enumerate(top_nodes):
    count = outlier_counts[node_id]
    percentage = count / len(data) * 100
    print(f"  {i+1}. 节点{node_id}: {count}个 ({percentage:.1f}%)")
```

### 可视化单个节点

```python
import matplotlib.pyplot as plt

node_id = 10
time_series = data[:, node_id]
is_outlier = outliers[:, node_id]

plt.figure(figsize=(15, 5))
plt.plot(time_series, label='原始数据', alpha=0.7)
plt.scatter(np.where(is_outlier)[0], 
           time_series[is_outlier],
           color='red', s=50, label='异常值', zorder=5)
plt.legend()
plt.title(f'节点{node_id}的异常值检测')
plt.xlabel('时间步')
plt.ylabel('流量')
plt.grid(alpha=0.3)
plt.show()
```

---

## 9️⃣ 常见问题 FAQ

### Q1: 为什么用1.5倍IQR而不是其他倍数？

**A**: 1.5是约翰·图基（John Tukey）在1977年提出的经验值：
- **统计意义**：正态分布下，约99.3%数据在此范围内
- **实践验证**：在大量数据集上表现良好
- **可调整**：可根据领域知识调整（保守用1.0，宽松用2.0）

### Q2: 异常值比例多高算"严重"？

**A**: 经验阈值：
- **<2%**: 🟢 优秀，数据质量好
- **2-5%**: 🟡 正常，可接受
- **5-10%**: 🟠 偏高，建议去噪
- **>10%**: 🔴 严重，需要数据清洗或强力去噪

### Q3: IQR vs Z-score 如何选择？

**A**: 选择标准：
```
数据分布已知为正态 → Z-score
数据分布未知/偏态 → IQR（推荐）
对极端值敏感     → IQR
需要概率解释     → Z-score
```

### Q4: 异常值一定要删除吗？

**A**: 不一定！
- ✅ **保留**：真实特殊事件（如节假日流量）
- ❌ **删除**：传感器故障、数据错误
- 🔧 **处理**：使用去噪模块自适应处理（推荐）

---

## 🎯 总结

### 核心要点

1. **异常值定义**：明显偏离正常范围的数据点
2. **检测方法**：IQR方法（鲁棒）或Z-score方法（快速）
3. **图表解读**：
   - 柱子高度 = 该节点异常值数量
   - 均匀低柱 = 数据质量好
   - 个别高柱 = 个别节点问题
   - 普遍高柱 = 系统性问题
4. **比例阈值**：<5%正常，>5%需关注
5. **处理建议**：根据比例选择去噪策略

### 快速决策树

```
异常值比例?
    │
    ├─ <2%  → 🟢 数据优秀，可不去噪
    │
    ├─ 2-5% → 🟡 数据良好，轻量去噪（conv）
    │
    └─ >5%  → 🔴 数据问题，强力去噪（attention）
```

---

**文档版本**: v1.0  
**最后更新**: 2025-11-17  
**适用于**: AGPST 交通流量预测项目
